// Generated by CoffeeScript 1.7.1
(function() {
  var ContinentsLoaded, Timestamp, constructPattern, getPatternPositions, parse, parseDate, sugar, tz, _, _MONTHS3_ENG, _patterns,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  sugar = require('sugar');

  _ = require('underscore');

  tz = require("timezone");

  Timestamp = module.exports;

  ContinentsLoaded = {};

  _MONTHS3_ENG = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];

  _patterns = {
    Y: "([0-9]{2,4})",
    M: "([0-9]{1,2})",
    MMM: "([\\w]{3})",
    D: "([0-9]{1,2})",
    H: "([0-9]{1,2})",
    m: "([0-9]{1,2})",
    s: "(?:[:]([0-9]{1,2}))?",
    date_date: "[-|//|\\s|,]*",
    time_time: "[:]",
    date_time: "[T|\\s]",
    undefined: "[-|//|\\s|,]*",
    f: "(\.[0-9]{1,3})?",
    t: "(?:[\\s])?([\\w]{2})?",
    o: "([\-|\+][0-9]{1,4})",
    w: "([\\w]*)"
  };

  getPatternPositions = function(pattern) {
    var group, i, patternSplit, positions, _i, _ref;
    patternSplit = pattern.split(/[/ /]|[-]|[T]|[\s]+|[\.]|[\s]*[,][\s]*|[:]/);
    positions = [];
    for (i = _i = 0, _ref = patternSplit.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      group = void 0;
      switch (patternSplit[i].charAt(0)) {
        case "Y":
          group = "date";
          break;
        case "M":
          group = "date";
          break;
        case "D":
          group = "date";
          break;
        case "H":
          group = "time";
          break;
        case "m":
          group = "time";
          break;
        case "s":
          group = "time_optional";
          break;
        case "f":
          group = "milli_optional";
          break;
        case "t":
          group = "timeOfDay_optional";
          break;
        case "+":
        case "-":
          group = "offset";
          break;
        case "w":
          group = "word";
      }
      if (group === void 0) {
        positions[i] = {
          "type": patternSplit[i],
          "len": patternSplit[i].length,
          "group": group
        };
      } else {
        if (patternSplit[i] === "MMM") {
          positions[i] = {
            "type": patternSplit[i],
            "len": patternSplit[i].length,
            "group": group
          };
        } else if (patternSplit[i].charAt(0) === "+" || patternSplit[i].charAt(0) === "-") {
          positions[i] = {
            "type": patternSplit[i].charAt(1),
            "len": patternSplit[i].length,
            "group": group
          };
        } else {
          positions[i] = {
            "type": patternSplit[i].charAt(0),
            "len": patternSplit[i].length,
            "group": group
          };
        }
      }
    }
    return positions;
  };

  constructPattern = function(patternPositions) {
    var NEUTRAL, groupCurr, groupNext, i, rString, _i, _ref;
    rString = "";
    NEUTRAL = ["offset", "word"];
    for (i = _i = 0, _ref = patternPositions.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (_.isUndefined(patternPositions[i].group)) {
        rString = rString + "(" + patternPositions[i].type + ")";
      } else {
        rString = rString + _patterns[patternPositions[i].type];
      }
      if (i < patternPositions.length - 1) {
        groupCurr = patternPositions[i].group;
        groupNext = patternPositions[i + 1].group;
        if (_.isUndefined(groupCurr) || _.isUndefined(groupNext) || __indexOf.call(NEUTRAL, groupNext) >= 0 || __indexOf.call(NEUTRAL, groupCurr) >= 0) {
          rString = rString + _patterns["undefined"];
        } else {
          if (_patterns[groupCurr + "_" + groupNext]) {
            rString = rString + _patterns[groupCurr + "_" + groupNext];
          }
        }
      }
    }
    return new RegExp(rString);
  };

  parseDate = function(dateIsoish, pattern, strictMode) {
    var amPm, constructed, dateIsoishCleanedArr, daytimeHoursToAdd, i, isOptionalPattern, j, paternPositions, r, typeShouldBe, wasOptional, yearXDigits, _i, _ref;
    if (pattern == null) {
      pattern = "YYYY/MM/DD HH:mm:ss.fff tt";
    }
    if (strictMode == null) {
      strictMode = false;
    }
    paternPositions = getPatternPositions(pattern);
    constructed = constructPattern(paternPositions);
    dateIsoishCleanedArr = dateIsoish.match(constructed);
    if (dateIsoishCleanedArr) {
      dateIsoishCleanedArr.removeAt(0);
    }
    isOptionalPattern = function(patternString) {
      return _.isUndefined(patternString) || _.isEqual(patternString.charAt(patternString.length - 1), "?") || !_.isEqual(patternString.charAt(0), "(");
    };
    r = {};
    j = 1;
    for (i = _i = 0, _ref = paternPositions.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      typeShouldBe = paternPositions[i].type;
      wasOptional = false;
      if (!isOptionalPattern(_patterns[typeShouldBe])) {
        if (dateIsoishCleanedArr[i] === void 0) {
          throw "datepattern " + pattern + " does not match date " + dateIsoish;
        }
      }
      amPm = "";
      if (dateIsoishCleanedArr[i] !== void 0) {
        switch (typeShouldBe) {
          case "f":
            r[typeShouldBe] = parseFloat(dateIsoishCleanedArr[i]) * 1000;
            break;
          case "t":
            if (dateIsoishCleanedArr[i].toLowerCase() === "pm") {
              amPm = "pm";
            } else {
              amPm = "am";
            }
            break;
          case "Y":
            yearXDigits = parseInt(dateIsoishCleanedArr[i]);
            if (yearXDigits < 100) {
              yearXDigits = 2000 + yearXDigits;
            }
            r[typeShouldBe] = yearXDigits;
            break;
          case "MMM":
            r[typeShouldBe] = _MONTHS3_ENG.indexOf(dateIsoishCleanedArr[i].toLowerCase()) + 1;
            break;
          case "M":
            r[typeShouldBe] = parseInt(dateIsoishCleanedArr[i]);
            break;
          case "o":
            r[typeShouldBe] = parseInt(dateIsoishCleanedArr[i]);
            break;
          default:
            r[typeShouldBe] = parseInt(dateIsoishCleanedArr[i]);
        }
      }
    }
    daytimeHoursToAdd = 0;
    if (amPm === "pm") {
      if (r["H"] === 12) {

      } else {
        daytimeHoursToAdd = 12;
      }
    } else {
      if (r["H"] === 12) {
        daytimeHoursToAdd = -12;
      }
    }
    r["H"] = r["H"] + daytimeHoursToAdd;
    return r;
  };

  Timestamp.pad = function(n, width, z) {
    if (z == null) {
      z = "0";
    }
    n = n + '';
    if (n.length >= width) {
      return n;
    } else {
      return new Array(width - n.length + 1).join(z) + n;
    }
  };

  parse = function(dateIsoish, pattern, continentCitiy, strictMode) {
    var city, continent, continentCities, dateParsed, day, hour, milliSecond, minute, month, monthRaw, r, second, sign;
    if (pattern == null) {
      pattern = "YYYY/MM/DD HH:mm:ss.fff tt";
    }
    if (continentCitiy == null) {
      continentCitiy = null;
    }
    if (strictMode == null) {
      strictMode = false;
    }
    dateParsed = parseDate(dateIsoish, pattern, strictMode);
    if (continentCitiy == null) {
      if (dateParsed.o == null) {
        throw new TypeError("either offset or continent city must be defined for timezone");
      }
      continent = "Etc";
      sign = dateParsed.o > 0 ? "+" : "";
      city = "GMT" + sign + dateParsed.o.toString();
    } else {
      continentCities = continentCitiy.split(/[ \/]|[\s]+|[:]/);
      continent = continentCities[0].trim();
      city = continentCities.length === 2 ? continentCities[1].trim() : continentCities[1].trim() + continentCities[2].trim();
    }
    if (ContinentsLoaded[continent] === void 0) {
      console.log("timestamp loded: " + continent);
      ContinentsLoaded[continent] = tz(new require("timezone/" + continent));
    }
    monthRaw = dateParsed["M"] || dateParsed["MMM"];
    month = Timestamp.pad(monthRaw.toString(), 2);
    day = Timestamp.pad(dateParsed["D"].toString(), 2);
    minute = "00";
    second = "00";
    milliSecond = "000";
    if (dateParsed["m"]) {
      minute = Timestamp.pad(dateParsed["m"].toString(), 2);
    }
    hour = Timestamp.pad(dateParsed["H"].toString(), 2);
    if (dateParsed["s"]) {
      second = Timestamp.pad(dateParsed["s"].toString(), 2);
    }
    if (dateParsed["f"]) {
      milliSecond = Timestamp.pad(dateParsed["f"].toString(), 3);
    }
    r = ContinentsLoaded[continent](dateParsed["Y"].toString() + "-" + month + "-" + day + "T" + hour + ":" + minute + ":" + second + "." + milliSecond, continent + "/" + city);
    return r;
  };

  Timestamp.parseDate = parseDate;

  Timestamp.parse = parse;

}).call(this);

//# sourceMappingURL=timestampGrabber.map
